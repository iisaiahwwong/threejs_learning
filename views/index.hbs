<script>
  const aspectRatio = window.innerWidth/ window.innerHeight;
  var scene = new THREE.Scene();
  var camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);

  var renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Responsiveness
  window.addEventListener('resize', function() {
    var width = window.innerWidth;
    var height = window.innerHeight;
    renderer.setSize(width, height);
    camera.aspect = width/height;
    camera.updateProjectionMatrix();
  });

  controls = new THREE.OrbitControls(camera, renderer.domElement);


  /**
   * create the shape
   * Width of 1, height of 1 and depth of 1
   */
  var geometry = new THREE.BoxGeometry(2,2,2);
  var cubeMaterials = [
    // RIGHT SIDE
    new THREE.MeshPhongMaterial({ map: new THREE.TextureLoader().load('images/img1.jpg'), side: THREE.DoubleSide }),
    // LEFT SIDE
    new THREE.MeshPhongMaterial({map: new THREE.TextureLoader().load('images/img1.jpg'), side: THREE.DoubleSide }),
    // TOP SIDE
    new THREE.MeshPhongMaterial({map: new THREE.TextureLoader().load('images/img1.jpg'), side: THREE.DoubleSide }),
    // BOTTOM SIDE
    new THREE.MeshPhongMaterial({map: new THREE.TextureLoader().load('images/img1.jpg'), side: THREE.DoubleSide }),
    // FRONT SIDE
    new THREE.MeshPhongMaterial({map: new THREE.TextureLoader().load('images/img1.jpg'),  side: THREE.DoubleSide}),
    // BACK SIDE
    new THREE.MeshPhongMaterial({map: new THREE.TextureLoader().load('images/img1.jpg'),  side: THREE.DoubleSide })
  ];

  // create a material, colour or image texture
//      var material = new THREE.MeshBasicMaterial({
//        color: 0xffffff, wireframe: true
//      });
  var material = new THREE.MultiMaterial(cubeMaterials);
  var cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  camera.position.z = 10;

  //Bottom
  var bottomGeometry = new THREE.CubeGeometry(10, 1, 10);
  var bottomMaterial = new THREE.MeshLambertMaterial({
    map: new THREE.TextureLoader().load('/images/crate.jpg'),
    side: THREE.DoubleSide
  });
  var bottomCube = new THREE.Mesh(bottomGeometry, bottomMaterial);

  bottomCube.position.y = -5;
  scene.add(bottomCube);

  //Top
  var topGeometry = new THREE.CubeGeometry(10, 1, 10);
  var topMaterial = new THREE.MeshLambertMaterial({
    map: new THREE.TextureLoader().load('/images/crate.jpg'),
    side: THREE.DoubleSide
  });
  var topCube = new THREE.Mesh(topGeometry, topMaterial);
  topCube.position.y = 5;
  scene.add(topCube);

  //Left
  var leftGeometry = new THREE.CubeGeometry(1, 10, 10);
  var leftMaterial = new THREE.MeshLambertMaterial({
    map: new THREE.TextureLoader().load('/images/crate.jpg'),
    side: THREE.DoubleSide
  });
  var leftCube = new THREE.Mesh(leftGeometry, leftMaterial);
  leftCube.position.x = 5;
  scene.add(leftCube);

  //Right
  var rightGeometry = new THREE.CubeGeometry(1, 10, 10);
  var rightMaterial = new THREE.MeshLambertMaterial({
    map: new THREE.TextureLoader().load('/images/crate.jpg'),
    side: THREE.DoubleSide
  });
  var rightCube = new THREE.Mesh(rightGeometry, rightMaterial);
  rightCube.position.x = -5;
  scene.add(rightCube);

  // Lighting
  var ambientLight = new THREE.AmbientLight('#ffffff', 0.8);
  scene.add(ambientLight);

//  var pointLight1 = new THREE.PointLight('#ff0040', 1.2, 50);
//  scene.add(pointLight1);
//
//  var pointLight2 = new THREE.PointLight('#0040ff', 1.1, 50);
//  scene.add(pointLight2);
//
//  var pointLight3 = new THREE.PointLight('#80ff80', 1.5, 50);
//  scene.add(pointLight3);
//
//  var directionalLight = new THREE.DirectionalLight('#ffffff', 1);
//  directionalLight.position.set(0, 1, 0);
//  scene.add(directionalLight);
//
//  var spotLight = new THREE.SpotLight('#ffffff', 1);
//  scene.add(spotLight);
  // Logic
  var update = function() {
    // Auto Rotation
    // cube.rotation.x += 0.01;
    // cube.rotation.y += 0.005;
    var time = Date.now() * 0.0005;

//    pointLight1.position.x = Math.sin(time* 0.7) * 30;
//    pointLight1.position.y = Math.cos(time* 0.5) * 40;
//    pointLight1.position.z = Math.cos(time* 0.3) * 30;
//
//    pointLight2.position.x = Math.cos(time* 0.3) * 30;
//    pointLight2.position.y = Math.sin(time* 0.5) * 40;
//    pointLight2.position.z = Math.sin(time* 0.7) * 30;
//
//    pointLight3.position.x = Math.sin(time* 0.7) * 30;
//    pointLight3.position.y = Math.cos(time* 0.3) * 40;
//    pointLight3.position.z = Math.sin(time* 0.5) * 30;

  };

  // Draw Scene
  var render = function() {
    renderer.render(scene, camera);
  };

  // Run game loop (update, render, repeat)
  var GameLoop = function() {
    requestAnimationFrame(GameLoop);

    update();
    render();
  };

  GameLoop();
</script>