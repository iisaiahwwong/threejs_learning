<div><p style="color: white; position: absolute; font-size: 100px">Hello</p></div>
<div id="container">

</div>
<script src="/js/vendor/Projector.js"></script>
<script src="/js/vendor/CanvasRenderer.js"></script>

<script>
	var camera, scene, renderer, controls;
	var mouse, raycaster;

	var width = window.innerWidth,
			height = window.innerHeight;

	var objects = [];

	$(function() {
		init();
		initCircleProperties();
		animate();
	});

	function init() {
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(60, width/height, .1, 500);
		camera.position.z = 10;

		renderer = new THREE.CanvasRenderer();
		renderer.setClearColor(0x000000, 0.1);
		renderer.setSize(width, height);

		controls = new THREE.OrbitControls(camera, renderer.domElement);

		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

		//add event listener for mouse and calls function when activated
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		document.addEventListener( 'touchstart', onDocumentTouchStart, false );

		$("#container").append(renderer.domElement);

		$(window).resize(function(){
			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;

			camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
			camera.updateProjectionMatrix();

			renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
		});
	}

	function onDocumentTouchStart( event ) {

		event.preventDefault();

		event.clientX = event.touches[0].clientX;
		event.clientY = event.touches[0].clientY;
		onDocumentMouseDown( event );

	}

	function onDocumentMouseDown( event ) {
		event.preventDefault();

		mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects(objects);

		if ( intersects.length > 0 ) {
			this.temp = intersects[ 0 ].object.userData;
			this.name = intersects[ 0 ].object.name;
			console.log(this.temp);
		}
	}

	var x, y, z, radius, angle;
	var obj, objResolution;

	var material, geometry;

	var colors=[0x379392,0x2E4952,0x0BC9C7];

	function initCircleProperties() {
		radius = 1;
		objResolution = 361;

		geometry = new THREE.Geometry();
		material = new THREE.LineBasicMaterial({
			color: colors[0],
			linewidth: 10
		});

		for(var i = 0; i < objResolution; i++) {
			// Convert angle to radians
			angle = i * Math.PI/180;

			// X Coordinates
			x = radius * Math.cos(angle);
			y = radius * Math.sin(angle);
			z = 0;

			geometry.vertices.push(new THREE.Vector3(x, y, z));
		}

		for(var i = 0; i < 3; i++) {
			obj = new THREE.Line(geometry, material);
			obj.position.z = i-1;
			obj.userData = { index: i };
			scene.add(obj);
			objects.push(obj);
		}
		var spritey = makeTextSprite( " Hello, ",
						{ fontsize: 24, borderColor: {r:255, g:0, b:0, a:1.0}, backgroundColor: {r:255, g:100, b:100, a:0.8} } );
		spritey.position.set(0,45,0);
		scene.add( spritey );
	}

	function makeTextSprite( message, parameters ) {
		if ( parameters === undefined ) parameters = {};
		var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
		var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
		var borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
		var borderColor = parameters.hasOwnProperty("borderColor") ?parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
		var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };
		var textColor = parameters.hasOwnProperty("textColor") ?parameters["textColor"] : { r:0, g:0, b:0, a:1.0 };

		var canvas = document.createElement('canvas');
		var context = canvas.getContext('2d');
		context.font = "Bold " + fontsize + "px " + fontface;
		var metrics = context.measureText( message );
		var textWidth = metrics.width;

		context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
		context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

		context.lineWidth = borderThickness;
		roundRect(context, borderThickness/2, borderThickness/2, (textWidth + borderThickness) * 1.1, fontsize * 1.4 + borderThickness, 8);

		context.fillStyle = "rgba("+textColor.r+", "+textColor.g+", "+textColor.b+", 1.0)";
		context.fillText( message, borderThickness, fontsize + borderThickness);

		var texture = new THREE.Texture(canvas)
		texture.needsUpdate = true;

		var spriteMaterial = new THREE.SpriteMaterial( { map: texture, useScreenCoordinates: false } );
		var sprite = new THREE.Sprite( spriteMaterial );
		sprite.scale.set(0.5 * fontsize, 0.25 * fontsize, 0.75 * fontsize);
		return sprite;
	}

	function roundRect(ctx, x, y, w, h, r)
	{
		ctx.beginPath();
		ctx.moveTo(x+r, y);
		ctx.lineTo(x+w-r, y);
		ctx.quadraticCurveTo(x+w, y, x+w, y+r);
		ctx.lineTo(x+w, y+h-r);
		ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
		ctx.lineTo(x+r, y+h);
		ctx.quadraticCurveTo(x, y+h, x, y+h-r);
		ctx.lineTo(x, y+r);
		ctx.quadraticCurveTo(x, y, x+r, y);
		ctx.closePath();
		ctx.fill();
		ctx.stroke();
	}

	function animate() {
		requestAnimationFrame(animate);
		renderer.render(scene, camera);
	}

</script>